<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Retro Blaster</title>
  <style>
    body {
      margin: 0; background: #080a0f; color: #e6f1ff;
      font: 16px/1.4 system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      display: flex; flex-direction: column; align-items: center;
    }
    #menu {
      width: 100%; max-width: 920px;
      background: linear-gradient(#0b1220, #0a0f1a);
      border-bottom: 1px solid #2a3952;
      padding: 12px; text-align: center;
    }
    #menu h1 { margin: 0 0 6px; font-size: 28px; letter-spacing: 1px; }
    #menu .subtitle { margin: 0 0 12px; color: #7a8aaa; }
    .btn {
      display: inline-block; margin: 4px; padding: 8px 14px;
      border: 1px solid #2a3952; border-radius: 8px;
      background: #101622; color: #e6f1ff; cursor: pointer;
    }
    .btn:hover { border-color: #39608f; }
    #frame {
      width: min(100%, 920px); aspect-ratio: 4 / 3;
      background: #000814; border: 1px solid #1c2433; border-radius: 12px;
      position: relative; overflow: hidden; margin-top: 8px;
    }
    canvas { width: 100%; height: 100%; display: block; image-rendering: pixelated; }
    #hud {
      position: absolute; inset: 0; pointer-events: none; padding: 10px 12px;
      display: flex; justify-content: space-between; gap: 8px; font-variant-numeric: tabular-nums;
    }
    .pill {
      pointer-events: auto;
      padding: 6px 10px; border: 1px solid #2a3952; border-radius: 999px;
      background: rgba(15,20,30,.5); color: #7a8aaa; display:inline-flex; align-items:center; gap:8px;
    }
    .pill b { color: #e6f1ff; }
    #mobileControls {
      position: absolute; left: 0; right: 0; bottom: 12px; display: none;
      gap: 12px; justify-content: center; pointer-events: none;
    }
    .touchbtn {
      pointer-events: auto; min-width: 72px;
      padding: 14px 16px; border-radius: 12px; border: 1px solid #2a3952;
      background: rgba(15,20,30,.55); color: #e6f1ff; font-weight: 700;
    }
    @media (hover:none), (max-width: 820px) {
      #mobileControls { display: flex; }
    }
    small.note { color: #9aa9c6; display:block; margin-top:8px; }
  </style>
</head>
<body>
  <div id="menu">
    <h1>RETRO BLASTER</h1>
    <p class="subtitle">Ein minimalistisches Arcade-Spiel ‚Äî kein Schnickschnack.</p>
    <div>
      <button class="btn" id="startBtn">‚ñ∂Ô∏è Spiel starten</button>
      <button class="btn" id="muteBtn">üîá Ohne Sound</button>
      <button class="btn" id="restartBtn">üîÅ Neustart</button>
    </div>
    <p style="color:#b6c3d9;font-size:14px;margin-top:10px;">
      Steuerung: ‚Üê / ‚Üí oder A/D bewegen, Leertaste = Feuer, P = Pause, R = Neustart
    </p>
    <small class="note">Hinweis: "Ohne Sound" startet stumm; mit "Spiel starten" wird Sound aktiviert (wenn der Browser Audio erlaubt).</small>
  </div>

  <div id="frame">
    <canvas id="game" width="800" height="600" aria-label="Retro Blaster Spiel"></canvas>
    <div id="hud" aria-hidden="true">
      <div class="pill">Punkte: <b id="score">0</b></div>
      <div class="pill">Leben: <b id="lives">3</b></div>
      <div class="pill">Level: <b id="level">1</b></div>
    </div>
    <div id="mobileControls" aria-hidden="true">
      <button class="touchbtn" id="leftBtn">‚Üê</button>
      <button class="touchbtn" id="fireBtn">‚óè</button>
      <button class="touchbtn" id="rightBtn">‚Üí</button>
    </div>
  </div>

<script>
(() => {
  // Canvas & DPI
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function fixDPI() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  new ResizeObserver(fixDPI).observe(canvas);
  fixDPI();

  // UI refs
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const levelEl = document.getElementById('level');
  const startBtn = document.getElementById('startBtn');
  const muteBtn = document.getElementById('muteBtn');
  const restartBtn = document.getElementById('restartBtn');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const fireBtn = document.getElementById('fireBtn');

  // Audio (simple beeps)
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audio = {
    enabled: true,
    ctx: null,
    beep(freq = 440, dur = 0.06, type = 'square', gain = 0.03) {
      if (!audio.enabled) return;
      try {
        if (!audio.ctx) audio.ctx = new AudioCtx();
        const t0 = audio.ctx.currentTime;
        const osc = audio.ctx.createOscillator();
        const g = audio.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        g.gain.value = gain;
        osc.connect(g).connect(audio.ctx.destination);
        osc.start(t0);
        osc.stop(t0 + dur);
      } catch (e) {
        // Einige Browser blockieren Audio ohne Nutzerinteraktion ‚Äî still fail silently
      }
    }
  };

  // State
  const STATE = { MENU: 0, RUN: 1, PAUSE: 2, GAMEOVER: 3 };
  let state = STATE.MENU;

  // Input
  const keys = { left: false, right: false, fire: false };
  let touch = { left: false, right: false, fire: false };

  // World
  const world = {
    w: 800, h: 600,
    player: { x: 400, y: 560, w: 36, h: 18, speed: 300, cd: 0, lives: 3 },
    bullets: [], enemyBullets: [], invaders: [], shields: [],
    dir: 1, invaderSpeed: 40, score: 0, level: 1, nextShotTimer: 0,
    layout: { cols: 10, rows: 5, gapX: 48, gapY: 36, marginX: 40, marginY: 60 }
  };

  // Helpers
  function syncHUD() {
    scoreEl.textContent = world.score | 0;
    livesEl.textContent = world.player.lives | 0;
    levelEl.textContent = world.level | 0;
  }
  function rectHit(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // Spawner
  function spawnInvaders(level = 1) {
    world.invaders.length = 0;
    const { cols, rows, gapX, gapY, marginX, marginY } = world.layout;
    const baseSpeed = 25 + (level - 1) * 8;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        world.invaders.push({
          x: marginX + c * gapX,
          y: marginY + r * gapY,
          w: 28, h: 20,
          alive: true,
          value: (rows - r) * 10,
          col: c, row: r
        });
      }
    }
    world.invaderSpeed = baseSpeed;
    world.dir = 1;
  }

  function spawnShields() {
    world.shields.length = 0;
    const shieldCount = 3, shieldW = 70, shieldH = 34, blocksX = 7, blocksY = 3;
    const gap = (world.w - shieldCount * shieldW) / (shieldCount + 1);
    for (let s = 0; s < shieldCount; s++) {
      const sx = gap + s * (shieldW + gap);
      const sy = world.h - 140;
      for (let y = 0; y < blocksY; y++) for (let x = 0; x < blocksX; x++) {
        world.shields.push({
          x: sx + x * (shieldW / blocksX),
          y: sy + y * (shieldH / blocksY),
          w: (shieldW / blocksX) - 2,
          h: (shieldH / blocksY) - 2,
          hp: 2
        });
      }
    }
  }

  // Input handling
  addEventListener('keydown', e => {
    if (e.repeat) return;
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') keys.left = true;
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') keys.right = true;
    if (e.code === 'Space') { keys.fire = true; e.preventDefault(); }
    if (e.key.toLowerCase() === 'p') togglePause();
    if (e.key.toLowerCase() === 'r') restart();
  });
  addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') keys.left = false;
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') keys.right = false;
    if (e.code === 'Space') keys.fire = false;
  });
  function bindTouch(btn, prop) {
    btn.addEventListener('pointerdown', ev => { ev.preventDefault(); touch[prop] = true; });
    btn.addEventListener('pointerup', ev => { ev.preventDefault(); touch[prop] = false; });
    btn.addEventListener('pointercancel', () => touch[prop] = false);
    btn.addEventListener('pointerleave', () => touch[prop] = false);
  }
  bindTouch(leftBtn, 'left'); bindTouch(rightBtn, 'right'); bindTouch(fireBtn, 'fire');

  // Game logic
  function reset(level = 1, keepScore = false) {
    world.w = canvas.clientWidth;
    world.h = canvas.clientHeight;
    world.player.x = world.w / 2;
    world.player.y = world.h - 40;
    world.player.cd = 0;
    world.player.lives = 3;
    world.bullets.length = 0;
    world.enemyBullets.length = 0;
    world.level = level;
    if (!keepScore) world.score = 0;
    spawnInvaders(level);
    spawnShields();
    syncHUD();
  }

  function bottomRow(invAlive) {
    // Return one invader-per-column at the lowest row (candidates to shoot)
    const byCol = new Map();
    for (const inv of invAlive) {
      const col = inv.col;
      const prev = byCol.get(col);
      if (!prev || inv.y > prev.y) byCol.set(col, inv);
    }
    return Array.from(byCol.values());
  }

  function hitPlayer() {
    world.player.lives--;
    syncHUD();
    audio.beep(120, 0.12, 'square', 0.06);
    if (world.player.lives <= 0) {
      gameOver();
    }
  }

  function gameOver() {
    state = STATE.GAMEOVER;
  }

  function togglePause() {
    if (state === STATE.RUN) state = STATE.PAUSE;
    else if (state === STATE.PAUSE) state = STATE.RUN;
  }

  function restart() {
    reset(1, false);
    state = STATE.RUN;
  }

  // Rendering helpers
  function drawPlayer(p, blink = false) {
    if (blink) return; // simple blink skip
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.fillStyle = "#5cff9d";
    ctx.fillRect(-18, -6, 36, 12);
    ctx.fillRect(-10, -10, 20, 4);
    ctx.fillRect(-4, -14, 8, 4);
    ctx.restore();
  }
  function drawInvader(x, y) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = "#9cc7ff";
    ctx.fillRect(-10, -8, 20, 4);
    ctx.fillRect(-12, -4, 24, 4);
    ctx.fillRect(-14, 0, 28, 4);
    ctx.fillRect(-18, 4, 36, 4);
    ctx.fillRect(-12, 8, 6, 4);
    ctx.fillRect(6, 8, 6, 4);
    ctx.clearRect(-6, -2, 4, 2);
    ctx.clearRect(2, -2, 4, 2);
    ctx.restore();
  }
  function drawShield(b) {
    ctx.fillStyle = b.hp === 2 ? "#6dd58f" : "#387a58";
    ctx.fillRect(b.x, b.y, b.w, b.h);
  }

  function banner(text) {
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    const w = Math.max(260, ctx.measureText(text).width + 40);
    const x = (canvas.clientWidth - w) / 2;
    const y = canvas.clientHeight / 2 - 26;
    ctx.fillRect(x, y, w, 52);
    ctx.fillStyle = "#e6f1ff";
    ctx.font = "700 18px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(text, canvas.clientWidth / 2, canvas.clientHeight / 2 + 8);
    ctx.restore();
  }

  function starsBackground(t) {
    ctx.save();
    ctx.fillStyle = "#000a16";
    ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);
    const cnt = 120;
    for (let i = 0; i < cnt; i++) {
      const x = (i * 97 + (t * 12)) % canvas.clientWidth;
      const y = (i * 61 + (t * 23)) % canvas.clientHeight;
      if (i % 11 === 0) ctx.fillStyle = "#203a73"; else if (i % 7 === 0) ctx.fillStyle = "#1b2947"; else ctx.fillStyle = "#0f1b33";
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.restore();
  }

  // Main update & loop
  let last = performance.now();
  function update(dt) {
    const p = world.player;
    const move = (keys.left || touch.left ? -1 : 0) + (keys.right || touch.right ? 1 : 0);
    p.x += move * p.speed * dt;
    const margin = 18;
    p.x = Math.max(margin, Math.min(world.w - margin, p.x));

    // Shooting
    p.cd -= dt;
    if ((keys.fire || touch.fire) && p.cd <= 0) {
      world.bullets.push({ x: p.x - 2, y: p.y - 14, w: 4, h: 10, vy: -520 });
      p.cd = 0.22;
      audio.beep(880, 0.05, 'square', 0.035);
    }

    // Update bullets
    for (const b of world.bullets) b.y += b.vy * dt;
    world.bullets = world.bullets.filter(b => b.y + b.h > 0);

    // Invader update
    const invAlive = world.invaders.filter(i => i.alive);
    if (invAlive.length === 0) {
      // next level
      world.level++;
      syncHUD();
      spawnInvaders(world.level);
      spawnShields();
      audio.beep(650, 0.12, 'square', 0.05);
      audio.beep(900, 0.12, 'square', 0.05);
      return;
    }

    // speed scaling
    const speedBoost = Math.min(180, (50 - invAlive.length) * 2.2);
    const v = world.invaderSpeed + speedBoost;

    let minX = Infinity, maxX = -Infinity;
    for (const inv of invAlive) {
      inv.x += world.dir * v * dt * 0.6;
      minX = Math.min(minX, inv.x - inv.w / 2);
      maxX = Math.max(maxX, inv.x + inv.w / 2);
    }
    if (minX < 12 || maxX > world.w - 12) {
      world.dir *= -1;
      for (const inv of invAlive) inv.y += 20;
    }

    // Enemy shooting
    world.nextShotTimer -= dt;
    if (world.nextShotTimer <= 0) {
      const shooters = bottomRow(invAlive);
      if (shooters.length) {
        const s = shooters[(Math.random() * shooters.length) | 0];
        world.enemyBullets.push({ x: s.x - 2, y: s.y + 10, w: 4, h: 10, vy: 200 + Math.random() * 120 });
        audio.beep(180, 0.06, 'square', 0.03);
      }
      world.nextShotTimer = 0.5 + Math.random() * 0.9;
    }

    for (const eb of world.enemyBullets) eb.y += eb.vy * dt;
    world.enemyBullets = world.enemyBullets.filter(b => b.y < world.h + 20);

    // Collisions: player bullets vs invaders
    for (const b of world.bullets) {
      for (const inv of invAlive) {
        if (inv.alive && rectHit({ x: b.x, y: b.y, w: b.w, h: b.h }, { x: inv.x - inv.w / 2, y: inv.y - inv.h / 2, w: inv.w, h: inv.h })) {
          inv.alive = false;
          b.y = -9999;
          world.score += inv.value;
          syncHUD();
          audio.beep(520, 0.06, 'square', 0.04);
          audio.beep(420, 0.05, 'square', 0.03);
          break;
        }
      }
    }

    // Bullets vs shields
    for (const s of world.shields) {
      if (s.hp <= 0) continue;
      for (const b of world.bullets) if (rectHit({ x: b.x, y: b.y, w: b.w, h: b.h }, s)) { s.hp--; b.y = -9999; audio.beep(300, 0.03); }
      for (const eb of world.enemyBullets) if (rectHit({ x: eb.x, y: eb.y, w: eb.w, h: eb.h }, s)) { s.hp--; eb.y = world.h + 999; audio.beep(260, 0.03); }
    }

    // Enemy bullets vs player
    for (const eb of world.enemyBullets) {
      if (rectHit({ x: eb.x, y: eb.y, w: eb.w, h: eb.h }, { x: p.x - 18, y: p.y - 9, w: 36, h: 18 })) {
        eb.y = world.h + 999;
        hitPlayer();
        break;
      }
    }

    // Invaders reach player
    for (const inv of invAlive) {
      const invRect = { x: inv.x - inv.w / 2, y: inv.y - inv.h / 2, w: inv.w, h: inv.h };
      if (invRect.y + invRect.h >= p.y - 4) {
        world.player.lives = 0;
        gameOver();
        return;
      }
      // Invaders collide with shields
      for (const s of world.shields) {
        if (s.hp > 0 && rectHit(invRect, s)) s.hp = 0;
      }
    }
  }

  // Render
  let blinkT = 0;
  function render(t) {
    fixDPI();
    starsBackground(t);

    // Shields
    for (const s of world.shields) if (s.hp > 0) drawShield(s);

    // Invaders
    for (const inv of world.invaders) if (inv.alive) drawInvader(inv.x, inv.y);

    // Bullets
    ctx.fillStyle = "#ffec6e";
    for (const b of world.bullets) ctx.fillRect(b.x, b.y, b.w, b.h);
    ctx.fillStyle = "#ff6e9a";
    for (const b of world.enemyBullets) ctx.fillRect(b.x, b.y, b.w, b.h);

    // Player blink effect when running
    blinkT += 0.016;
    const blink = state === STATE.RUN && Math.sin(blinkT * 20) > 0.6 && world.player.lives < 3;
    if (state !== STATE.GAMEOVER) drawPlayer(world.player, blink);

    // Banners
    if (state === STATE.PAUSE) banner("PAUSE ‚Äî Dr√ºcke P zum Fortsetzen");
    else if (state === STATE.GAMEOVER) banner(`GAME OVER ¬∑ Punkte: ${world.score | 0} ¬∑ Dr√ºcke "Neustart" oder R`);
  }

  // Game loop
  function loop(ts) {
    const now = ts || performance.now();
    const dt = Math.min(0.033, (now - last) / 1000 || 0);
    last = now;
    if (state === STATE.RUN) update(dt);
    render(now / 1000);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // UI buttons
  startBtn.addEventListener('click', () => {
    audio.enabled = true;
    if (!audio.ctx) try { audio.ctx = new AudioCtx(); } catch (e) {}
    reset(1, false);
    state = STATE.RUN;
  });
  muteBtn.addEventListener('click', () => {
    audio.enabled = false;
    reset(1, false);
    state = STATE.RUN;
  });
  restartBtn.addEventListener('click', () => {
    restart();
  });

  // Init in MENU state (no auto-start)
  reset(1, false);
  state = STATE.MENU;
  syncHUD();

  // Optional: make the menu buttons visible stateful (small UX nicety)
  function updateMenuButtons() {
    // Nothing fancy ‚Äî user can always press buttons.
  }
  setInterval(updateMenuButtons, 1000);
})();
</script>
</body>
</html>
